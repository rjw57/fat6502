<html>
<head>
<title>C-ONE BOOT - project homepage</title>
<meta name="keywords" content="commodore, one, c1, c-one, boot">
<meta name="description" content="Project homepage for the C-ONE boot ROM development">
<meta name="author" content="Per Olofsson">
<link rel="stylesheet" href="default.css" type="text/css">
</head>

<body>

<a href="http://sourceforge.net"><img src="http://sourceforge.net/sflogo.php?group_id=78686&type=1" border="0" alt="SourceForge.net Logo" align="right"></A>
<h1>C-ONE BOOT - technical details</h1>

<p>

<hr>

<p align="center">

<a href="index.html">OVERVIEW</a> |
TECHNICAL |
<a href="http://sourceforge.net/projects/c1boot/">SF.NET PROJECT PAGE</a> |
<a href="http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/c1boot/">BROWSE CVS</a>

</p>

<hr>

</p>



<h2>Disclaimer</h2>

Please remember that all this is subject to change. More details will
be added later on.



<h2>Debug Output</h2>

The boot ROM prints debug output to RS-232, if you have a Silver
Surfer plugged into clock port 1. Set your terminal program to 38400
baud, 8N1, and hardware flow control.



<h2>The Drive CPU</h2>

The CPU core in the 1K30 is referred to as the drive CPU. When the
main system is up and running, the 6502 core works as a coprocessor.
Currently the core is running at around 2 MHz, but I have no idea if
the instruction timings are identical to that of a real 6502. At the
time of writing, the core differs from a genuine 6502 in the following
ways:

<ul>
  <li> There are no IRQs
  <li> A number of custom instructions have been added.
  <li> The lda/sta (zp,x) addressing mode has been removed (I think).
</ul>



<h2>Memory Map</h2>

There are two free memory ranges in the address space, $0080-$00bf,
and $2000-$3eff. If you call any provided routines from your code,
these are the only areas that are guaranteed not to be overwritten.
The cluster buffer ($4000-$bfff) is free to be used, but some routines
overwrite it (notably the vol_dir_* routines).


<pre><b>LORAM AREA</b>

system zp		0000-007f	; reserved for system use
application zp		0080-00bf	; free for application use
(reserved)    	    	00c0-00df
sectorptr		00e0-00e1	; where dev_read_sector stores data
(reserved)		00e2-00ef
dirptr			00f0-00f1	; pointer to current dir entry
clusterptr		00f2-00f3	; where vol_read_clust stores data
(reserved)		00f4-00ff

system stack		0100-01ff	; CPU stack

system variable storage	0200-1eff	; reserved for system use
romaddr			1f00-1f05	; ascii address set by vol_isrom
stat_length		1f06-1f09	; length, set by vol_stat
stat_cluster		1f0a-1f0d	; first cluster, set by vol_stat
vol_fstype		1f0e		; file system type, one of:
					;   $12 = FAT12
					;   $16 = FAT16
					;   $32 = FAT32
					;   $96 = ISO9660
vol_secperclus		1f0f		; # of 512 byte sectors in one cluster
cluster			1f10		; set before calling vol_read_clust
					; or vol_next_clust
(reserved)		1f14-1f3f
lba			1f40		; set before calling dev_read_sector
devtype			1f44		; current device type
(reserved)		1f45-1fff
flashbuf		2000-3eff	; reserved for flash code or
					; application code


<b>MEMORY MAPPED I/O AREA</b>

ROML			3f00-3f0f	; cartridge port chip select
I/O2			3f10-3f1f	; cartridge port chip select
clock port 1		3f20-3f2f	; clock port 1 is mapped here
					; a silver surfer plugged in here is
					; used by the debug_* routines
SID 1			3f30-3f3f	; only 16 registers, can't use SID
ROMH			3f40-3f4f	; cartridge port chip select
I/O1			3f50-3f5f	; cartridge port chip select
clock port 2		3f60-3f6f	; clock port 2 is mapped here, and also
					; the flash programming registers
clear flash address	3f60		; set the flash address to $00000
preset flash address 1	3f62		; set the flash address to $00555
preset flash address 2	3f64		; set the flash address to $002aa
shift flash address	3f66		; shift the flash address left
incr. flash address	3f68		; increment flash address by one
flash data reg 0	3f6c		; data register for $00000 - $1ffff
flash data reg 1	3f6d		; data register for $20000 - $3ffff
flash data reg 2	3f6e		; data register for $40000 - $5ffff
flash data reg 3	3f6f		; data register for $60000 - $7ffff
SID 2			3f70-3f7f	; only 16 registers, can't use SID
(reserved)		3f80-3fff


<b>HIRAM AREA</b>

clusterbuf		4000-bfff	; used by vol_*


<b>ROM AREA</b>

system code		c000-feff	; reserved for system code
jump table		ff00-ffdf	; system jump table
ver_major		fff0		; major version number
ver_minor		fff1		; minor version number
ver_rev			fff2		; revision number
ver_str			fff3-fff9	; 0 terminated version string
irq vector		fffa-fffb	; CPU IRQ vector (not used)
reset vector		fffc-fffd	; CPU reset vector
nmi vector		fffe-ffff	; CPU NMI vector


<b>SYSTEM JUMP TABLE</b>

vol_set_fs		ff00		; activate filesystem
vol_read_volid		ff03		; read volume info
vol_cdboot		ff06		; change to boot directory
vol_cdroot		ff09		; set cluster to root dir
vol_dir_first		ff0c		; set dirptr to first dir entry
vol_dir_next		ff0f		; advance dirptr to the next entry
vol_next_clust		ff12		; find the next cluster in the chain
vol_read_clust		ff15		; read cluster
vol_endofdir		ff18		; check for end of dir
vol_isfpgabin		ff1b		; check if entry is ?FPGA.BIN
vol_isrom		ff1e		; check if entry is ?R??????.BIN
vol_isflashbin		ff21		; check if entry is FLASH.BIN
vol_isdrivebin		ff24		; check if entry is ?DRIVE.BIN
vol_stat		ff27		; copy cluster and length
vol_firstnamechar	ff2a		; return first char in filename

dev_init		ff40		; initialize device
dev_read_sector		ff43		; read sector
dev_set			ff46		; activate device
dev_find_volume		ff49		; inspect filesystem

ctl_select		ff50		; activate controller
ctl_select_dev		ff53		; select device

debug_init		ff60		; initialize rs-232 debugging
debug_done		ff63		; disable rs-232 debugging
debug_puts		ff66		; print string
debug_get		ff69		; get character
debug_put		ff6c		; print character
debug_puthex		ff6f		; print hex number
debug_putdigit		ff72		; print digit
debug_crlf		ff75		; print cr+lf

gfx_cls			ff80		; clear the screen
gfx_drawlogo		ff83		; draw C-ONE logo
gfx_gotoxy		ff86		; set cursor position
gfx_puts		ff89		; print string
gfx_putchar		ff8c		; print character
gfx_quickcls		ff8f		; clear text area
gfx_drawicon		ff92		; draw 32x32 icon
gfx_puthex		ff95		; print hex byte
</pre>



<h2>How to program the Flash ROM</h2>

For a detailed article on how to use the flash programming registers,
see <a href="c1flash.shtml">Flashing the C-One Flash ROM</a>.



<h2>Custom Instructions</h2>

Common to all the instructions is that they don't set the processor
flags. E.g. you can't use

<pre>
    lda #ide_status  ; status register
    csa              ; set IDE address
waitbsy:
    ild              ; read register
    bmi waitbsy      ; does NOT work
</pre>

You need to add a cmp #$00, and #$ff, or some other regular 6502
instruction before you check the registers.


<h3>CSA, select address</h3>

CSA uses the value in the accumulator to the IDE address pins:

<pre>  bit 0-2  IDE interface A0-A2
  bit 3    select IDE channel, 0 = primary, 1 = secondary
  bit 4-7  unused, set to 0</pre>


<h3>CTL, system control</h3>

CTL uses the value in the accumulator to control various I/O lines:

<pre>  bit 0    CPU DMA control line, active low
  bit 1    strobe 0 to erase FPGA, keep set to 1
  bit 2    CPU RESET control line, active low
  bit 3-7  unused, set to 0</pre>


<h3>ILD, IDE load from register</h3>

Loads A and X from the currently selected IDE register. The LSB ends
up in A, and if register 0 is read the MSB ends up in X, otherwise X
is trashed.


<h3>IST, IDE store to register</h3>

Stores A and X to the currently selected IDE register, see ILD.


<h3>SAB, system address bank</h3>
<h3>SAU, system address upper</h3>
<h3>SAL, system address lower</h3>

SAB/SAU/SAL are used to select an address in the main CPU RAM. SAB sets
bits 16-23 from A, SAU sets bits 8-15 from A, SAL sets bits 0-7 from A.


<h3>MLD, memory load</h3>

MLD loads the byte pointed to by SAB/SAU/SAL from main CPU RAM into A.


<h3>MST, memory store</h3>

MST stores the byte in A to the address pointed to by SAB/SAU/SAL.


<h3>SAF, store accumulator to FPGA</h3>

SAF sends the current value in A to the config port of the 1K100.


<h3>LKA, load keyboard</h3>

LKA loads the next byte from the PS/2 keyboard FIFO into A. Carry is
set if the FIFO is empty (and the contents of A invalid).


<h3>GAX, set graphics address X</h3>
<h3>GAY, set graphics address Y</h3>
<h3>GAB, set graphics address bank</h3>
<h3>GST, write pixels</h3>

Set the graphics cursor address. The drive cpu can address a 640x512
pixel screen, arranged as a monochrome planar bitmap. GAX sets the
offset within a rasterline, 0..79. GAY sets bits 1..8 of the
rasterline. Bit 0 is controlled by the lowest bit in GAB. This
slightly strange arrangement is meant to accelerate text printing by
only drawing every other rasterline. GST stores the byte in A as 8
pixels at the location pointed to by GAX/GAY/GAB.


</body>
</html>
