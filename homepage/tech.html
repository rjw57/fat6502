<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
          "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>C-ONE BOOT - project homepage</title>
<meta name="keywords" content="commodore, one, c1, c-one, boot" />
<meta name="description" content="Project homepage for the C-ONE boot ROM development" />
<meta name="author" content="Per Olofsson" />
<link rel="stylesheet" href="default.css" type="text/css" />
</head>

<body>

<a href="http://sourceforge.net"><img src="http://sourceforge.net/sflogo.php?group_id=78686&amp;type=1" border="0" alt="SourceForge.net Logo" align="right" /></a>
<h1>C-ONE BOOT - technical details</h1>

<hr />

<p align="center">

<a href="index.html">OVERVIEW</a> |
TECHNICAL |
<a href="http://sourceforge.net/projects/c1boot/">SF.NET PROJECT PAGE</a> |
<a href="http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/c1boot/">BROWSE CVS</a>

</p>

<hr />



<h2>Disclaimer</h2>

Please remember that all this is subject to change. More details will
be added later on.



<h2>Debug Output</h2>

The boot ROM prints debug output to RS-232, if you have a Silver
Surfer plugged into clock port 1. Set your terminal program to 38400
baud, 8N1, and hardware flow control.



<h2>CPC Boot Environment</h2>




<h2>The Drive CPU</h2>

The CPC core in the 1K30 is referred to as the drive CPU. When the
main system is up and running, the CPC core works as a coprocessor.
Currently the RISC CPU core is running at 9 MHz, and the 6502
emulation runs at roughly 1.5 MHz. At the time of writing, the 6502
emulation differs from a genuine 6502 in the following ways:

<ul>
  <li> There are no IRQs</li>
  <li> A number of custom instructions have been added.</li>
</ul>



<h2>RISC CPU Memory Map</h2>

<table>

  <tr>
    <td class="hexaddr"><tt>$00000..$3ffff</tt></td>
    <td>
      Miscellaneous use:
      <ul>
	<li>temporary memory for XModem transfers</li>
	<li>disk images for CPC mode</li>
	<li>temporary space during flash procedure</li>
      </ul>
    </td>
  </tr>

  <tr>
    <td class="hexaddr"><tt>$40000..$7ffff</tt></td>
    <td>
      DK'tronics memory expansion for Amstrad computer mode (256KBytes)
    </td>
  </tr>

  <tr>
    <td class="hexaddr"><tt>$80000..$8ffff</tt></td>
    <td>
      CPU emulation code (Z80 and 6502)
    </td>
  </tr>

  <tr>
    <td class="hexaddr"><tt>$90000..$93fff</tt></td>
    <td>
      Amstrad OS (lowrom)
    </td>
  </tr>

  <tr>
    <td class="hexaddr"><tt>$94000..$9bfff</tt></td>
    <td>
      memory for shadowed Z80 (Amstrad floppy emulation)
    </td>
  </tr>

  <tr>
    <td class="hexaddr"><tt>$9c000..$9ffff</tt></td>
    <td>
      rom routines for floppy emulation
    </td>
  </tr>

  <tr>
    <td class="hexaddr"><tt>$a0000..$abfff</tt></td>
    <td>
      6502 memory. This memory is the 'standard' memory for the 6502
      processor. There are special commands that can access any other
      memory address for easy signalling between the CPUs and to give
      BigBoot the ability to load ROMs.
    </td>
  </tr>

  <tr>
    <td class="hexaddr"><tt>$ac000..$affff</tt></td>
    <td>
      6502 boot code.
    </td>
  </tr>

  <tr>
    <td class="hexaddr"><tt>$b0000..$bbfff</tt></td>
    <td>
      48K memory for Z80 emulation. This memory is CPC memory (by
      nature). There are special Z80 commands that give access to any
      other memory address for easy signalling between CPUs and to
      give access to ROM clones and the DK'tronics memory expansion.
    </td>
  </tr>

  <tr>
    <td class="hexaddr"><tt>$bc000..$bffff</tt></td>
    <td>
      16K memory shared between Z80 and the Amstrad video controller.
    </td>
  </tr>

  <tr>
    <td class="hexaddr"><tt>$c0000..$fffff</tt></td>
    <td>
      CPC rom expansion box (available as highrom in the upper 16K
      area). There are 16 slots for ROM modules. The real CPC
      expansion used 27128 eprom sockets that could be filled by the
      user. The slots are arranged linearly in this area, so the 16K
      area starting at $c0000 is slot 0.
    </td>
  </tr>

</table>



<h2>Flash ROM contents</h2>

<table>

  <tr>
    <td class="hexaddr"><tt>$00000..$0ffff</tt></td>
    <td rowspan="4">
      Reserved for future use (probably romfs with default 1k100
      config and bootrom backup).
    </td>
  </tr>

  <tr>
    <td class="hexaddr"><tt>$10000..$1ffff</tt></td>
  </tr>

  <tr>
    <td class="hexaddr"><tt>$20000..$2ffff</tt></td>
  </tr>

  <tr>
    <td class="hexaddr"><tt>$30000..$3ffff</tt></td>
  </tr>

  <tr>
    <td class="hexaddr"><tt>$40000..$4ffff</tt></td>
    <td>
      Z80 and 6502 emulation code, copied to $80000 at power on.
    </td>
  </tr>

  <tr>
    <td class="hexaddr"><tt>$50000..$5ffff</tt></td>
    <td>
      Amstrad ROMs, copied to $90000 at power on.
    </td>
  </tr>

  <tr>
    <td class="hexaddr"><tt>$60000..$6ffff</tt></td>
    <td>
      1k30 core.
    </td>
  </tr>

  <tr>
    <td class="hexaddr"><tt>$70000..$7ffff</tt></td>
    <td>
      6502 boot code.
    </td>
  </tr>

</table>



<h2>I/O Port Addresses</h2>

These are accessed with IN/OUT (Z80) and ZIN/ZOUT (6502).

<table>

  <tr>
    <td class="hexaddr">$7f</td>
    <td>
      Gate array and memory management.
    </td>
  </tr>

  <tr>
    <td class="hexaddr">$bc..$bd</td>
    <td>
      6845 CRTC. Available registers are: R1, R4, R5, R6, R7, R9, R12,
      and R13.
    </td>
  </tr>

  <tr>
    <td class="hexaddr">$df</td>
    <td>
      ROM select.
    </td>
  </tr>

  <tr>
    <td class="hexaddr">$ef</td>
    <td>
      Printer port (currently not working).
    </td>
  </tr>

  <tr>
    <td class="hexaddr">$f4..f7</td>
    <td>
      PPI.
    </td>
  </tr>

</table>



<h2>C-ONE I/O Bus</h2>

These are accessed with SCA and IST/ILD (6502).

<table>

  <tr>
    <td class="hexaddr">$0000..$efff</td>
    <td>
      Reserved for future use.
    </td>
  </tr>

  <tr>
    <td class="hexaddr">$f000..$f0ff</td>
    <td>
      Cartridge port <span class="invert">ROML</span>.
    </td>
  </tr>

  <tr>
    <td class="hexaddr">$f100..$f1ff</td>
    <td>
      Cartridge port <span class="invert">I/O2</span>.
    </td>
  </tr>

  <tr>
    <td class="hexaddr">$f200..$f2ff</td>
    <td>
      Clock port 1 (Silver Surfer).
    </td>
  </tr>

  <tr>
    <td class="hexaddr">$f300..$f3ff</td>
    <td>
      SID socket 1 (left channel).
    </td>
  </tr>

  <tr>
    <td class="hexaddr">$f400..$f4ff</td>
    <td>
      Cartridge port <span class="invert">ROMH</span>.
    </td>
  </tr>

  <tr>
    <td class="hexaddr">$f500..$f5ff</td>
    <td>
      Cartridge port <span class="invert">I/O1</span>.
    </td>
  </tr>

  <tr>
    <td class="hexaddr">$f600..$f6ff</td>
    <td>
      Clock port 2.
    </td>
  </tr>

  <tr>
    <td class="hexaddr">$f700..$f7ff</td>
    <td>
      SID socket 2 (right channel).
    </td>
  </tr>

  <tr>
    <td class="hexaddr">$f800..$f8ff</td>
    <td>
      Enable status register buffer.
    </td>
  </tr>

  <tr>
    <td class="hexaddr">$f900..$f9ff</td>
    <td>
      Printer port data output register latch.
    </td>
  </tr>

  <tr>
    <td class="hexaddr">$fa00..$faff</td>
    <td>
      Printer port DDR register latch.
    </td>
  </tr>

  <tr>
    <td class="hexaddr">$fb00..$fbff</td>
    <td>
      Serial port registers.
    </td>
  </tr>

  <tr>
    <td class="hexaddr">$fc00..$fcff</td>
    <td>
      PCI GRNT RESET.
    </td>
  </tr>

  <tr>
    <td class="hexaddr">$fd00..$fdff</td>
    <td>
      PCI0 GRNT SET.
    </td>
  </tr>

  <tr>
    <td class="hexaddr">$fe00..$feff</td>
    <td>
      PCI1 GRNT SET.
    </td>
  </tr>

  <tr>
    <td class="hexaddr">$ff00..$ffff</td>
    <td>
      Release chip selects. Read from $ffff after accessing I/O.
    </td>
  </tr>

</table>



<h2>6502 Memory Map</h2>

There are two free memory ranges in the address space, $0080-$00bf,
and $2000-$3eff. If you call any provided routines from your code,
these are the only areas that are guaranteed not to be overwritten.
The cluster buffer ($4000-$bfff) is free to be used, but some routines
overwrite it (notably the vol_* routines).


<pre><b>LORAM AREA</b>

system zp		0000-007f	; reserved for system use
application zp		0080-00bf	; free for application use
(reserved)    	    	00c0-00df
sectorptr		00e0-00e1	; where dev_read_sector stores data
(reserved)		00e2-00ef
dirptr			00f0-00f1	; pointer to current dir entry
clusterptr		00f2-00f3	; where vol_read_clust stores data
(reserved)		00f4-00ff

system stack		0100-01ff	; CPU stack

system variable storage	0200-1eff	; reserved for system use
romaddr			1f00-1f05	; ascii address set by vol_isrom
stat_length		1f06-1f09	; length, set by vol_stat
stat_cluster		1f0a-1f0d	; first cluster, set by vol_stat
vol_fstype		1f0e		; file system type, one of:
					;   $12 = FAT12
					;   $16 = FAT16
					;   $32 = FAT32
					;   $96 = ISO9660
vol_secperclus		1f0f		; # of 512 byte sectors in one cluster
cluster			1f10		; set before calling vol_read_clust
					; or vol_next_clust
(reserved)		1f14-1f3f
lba			1f40		; set before calling dev_read_sector
devtype			1f44		; current device type
(reserved)		1f45-1fff
flashbuf		2000-3eff	; reserved for flash code or
					; application code


<b>MEMORY MAPPED I/O AREA</b>

Reserved for future use.
<!--
ROML			3f00-3f0f	; cartridge port chip select
I/O2			3f10-3f1f	; cartridge port chip select
clock port 1		3f20-3f2f	; clock port 1 is mapped here
					; a silver surfer plugged in here is
					; used by the debug_* routines
SID 1			3f30-3f3f	; only 16 registers, can't use SID
ROMH			3f40-3f4f	; cartridge port chip select
I/O1			3f50-3f5f	; cartridge port chip select
clock port 2		3f60-3f6f	; clock port 2 is mapped here, and also
					; the flash programming registers
clear flash address	3f60		; set the flash address to $00000
shift flash address	3f66		; shift the flash address left
incr. flash address	3f68		; increment flash address by one
flash data reg 0	3f6c		; data register for $00000 - $1ffff
flash data reg 1	3f6d		; data register for $20000 - $3ffff
flash data reg 2	3f6e		; data register for $40000 - $5ffff
flash data reg 3	3f6f		; data register for $60000 - $7ffff
SID 2			3f70-3f7f	; only 16 registers, can't use SID
(reserved)		3f80-3fff
-->

<b>HIRAM AREA</b>

clusterbuf		4000-bfff	; used by vol_*


<b>ROM AREA</b>

system code		c000-feff	; reserved for system code
jump table		ff00-ffdf	; system jump table
ver_major		fff0		; major version number
ver_minor		fff1		; minor version number
ver_rev			fff2		; revision number
ver_str			fff3-fff9	; 0 terminated version string
irq vector		fffa-fffb	; CPU IRQ vector (not used)
reset vector		fffc-fffd	; CPU reset vector
nmi vector		fffe-ffff	; CPU NMI vector


<b>SYSTEM JUMP TABLE</b>

vol_set_fs		ff00		; activate filesystem
vol_read_volid		ff03		; read volume info
vol_cdboot		ff06		; change to boot directory
vol_cdroot		ff09		; set cluster to root dir
vol_dir_first		ff0c		; set dirptr to first dir entry
vol_dir_next		ff0f		; advance dirptr to the next entry
vol_next_clust		ff12		; find the next cluster in the chain
vol_read_clust		ff15		; read cluster
vol_endofdir		ff18		; check for end of dir
vol_isfpgabin		ff1b		; check if entry is ?FPGA.BIN
vol_isrom		ff1e		; check if entry is ?R??????.BIN
vol_isflashbin		ff21		; check if entry is FLASH.BIN
vol_isdrivebin		ff24		; check if entry is ?DRIVE.BIN
vol_stat		ff27		; copy cluster and length
vol_firstnamechar	ff2a		; return first char in filename
vol_write_clust		ff2d		; write cluster

dev_init		ff40		; initialize device
dev_read_sector		ff43		; read sector
dev_set			ff46		; activate device
dev_find_volume		ff49		; inspect filesystem
dev_write_sector	ff4c		; write sector

ctl_select		ff50		; activate controller
ctl_select_dev		ff53		; select device

debug_init		ff60		; initialize rs-232 debugging
debug_done		ff63		; disable rs-232 debugging
debug_puts		ff66		; print string
debug_get		ff69		; get character
debug_put		ff6c		; print character
debug_puthex		ff6f		; print hex number
debug_putdigit		ff72		; print digit
debug_crlf		ff75		; print cr+lf

gfx_cls			ff80		; clear the screen
gfx_drawlogo		ff83		; draw C-ONE logo
gfx_gotoxy		ff86		; set cursor position
gfx_puts		ff89		; print string
gfx_putchar		ff8c		; print character
gfx_quickcls		ff8f		; clear text area
gfx_drawicon		ff92		; draw 32x32 icon
gfx_puthex		ff95		; print hex byte

dsk_load		ffa0		; load DSK image
dsk_save		ffa3		; save DSK image
</pre>



<!--
<h2>How to program the Flash ROM</h2>

For a detailed article on how to use the flash programming registers,
see <a href="c1flash.shtml">Flashing the C-One Flash ROM</a>.
-->


<h2>Custom Instructions</h2>

Common to all the instructions are that they don't set the processor
flags. E.g. you can't use

<pre>
    lda #ide_status  ; status register
    csa              ; set IDE address
waitbsy:
    ild              ; read register
    bmi waitbsy      ; does NOT work
</pre>

You need to add a cmp #$00, and #$ff, or some other regular 6502
instruction before you check the registers.


<h3>CTL, system control</h3>

CTL uses the value in the accumulator to control various I/O lines:

<pre>  bit 0    CPU DMA control line, active low
  bit 1    strobe 0 to erase FPGA, keep set to 1
  bit 2    CPU RESET control line, active low
  bit 3-7  unused, set to 0</pre>


<h3>CSA, select address</h3>

CSA uses the value in the accumulator to address the IDE vus:

<pre>  bit 0-2  IDE interface A0-A2
  bit 3    select IDE channel, 0 = primary, 1 = secondary
  bit 4-7  unused, set to 0</pre>


<h3>SCA, set control address</h3>

SCA is used to address the C-ONE I/O bus. The X register is latched as
the MSB and the A register is latched as the LSB.



<h3>ILD, load from I/O bus</h3>

Loads A and X from the currently selected I/O register. The LSB ends
up in A, and if register 0 is read the MSB ends up in X, otherwise X
is trashed.


<h3>IST, store to I/O bus</h3>

Stores A and X to the currently selected I/O register, see ILD.


<h3>LAM, load accumulator from memory</h3>

Loads A from the 24-bit RISC memory location pointed to by the 16-bit
argument. This works like lda (zp), except the location is 24-bit and
doesn't have to be stored in zeropage.


<h3>SAM, store accumulator to memory</h3>

Store A to RISC memory, see LAM for a description of the addressing
mode.


<h3>SAF, store accumulator to FPGA</h3>

SAF sends the current value in A to the config port of the 1K100.


<h3>LKA, load keyboard</h3>

LKA loads the next byte from the PS/2 keyboard FIFO into A. Carry is
set if the FIFO is empty (and the contents of A invalid).


<h3>ZIN</h3>

ZIN reads a byte from the Z80 I/O address space.


<h3>ZOUT</h3>

ZOUT writes a byte to the Z80 I/O address space.



</body>
</html>
