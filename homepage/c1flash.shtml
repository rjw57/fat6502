<html>
<head>
<title>C-ONE BOOT - project homepage</title>
<meta name="keywords" content="commodore, one, c1, c-one, boot">
<meta name="description" content="Project homepage for the C-ONE boot ROM development">
<meta name="author" content="Per Olofsson">
<link rel="stylesheet" href="default.css" type="text/css">
</head>

<body>

<a href="http://sourceforge.net"><img src="http://sourceforge.net/sflogo.php?group_id=78686&type=1" border="0" alt="SourceForge.net Logo" align="right"></A>

<h1>Flashing the C-One Flash ROM</h1>

<p>

<i>by Jens Schönfeld. Any suggestions to <a href="mailto:jens@ami.ga">jens@ami.ga</a>
  - thanks!</i>

<h3>History</h3>

<ul>
  <li> August 16th 2003: Initial release
  <li> August 17th 2003: Added AMD notes
</ul>


<h2>Overview</h2>

<p>
The C-One reconfigurable computer's flash rom was initially not meant to be
programmed from "inside" the computer. The following documentation only
applies to boards that have either been reworked, or shipped after
August 16th, 2003.
</p>

<p>
With this rework, the flash rom appears in the CPU's memory map through
a bottleneck. This bottleneck is designed to be as fast as possible.
Given the fact that all the logic had to fit in the existing
32-macrocell CPLD, it's all we can do. The estimated time for flashing
a 128K flash rom is below 1 minute. The rework even gives the
possibility to access a 512K flash rom in the socket of the reworked
mainboard.
</p>

<p>
Access to the rom is done by first storing the address in the address
register, and then accessing the byte you chose at one of the four byte
registers.
</p>

<p>
The Address register is 17 bits wide. It allows access to 128K of flash rom
space. If a 512K flash rom is located in the socket, the two additional bits
that are necessary are given by the number of the byte register that is being
used to access the chip: Each of the four registers selects one of the four
128K blocks of a 512K flash rom. If a 128K flash chip is used, the four byte
registers are identical.
</p>


<h2>Setting the address register</h2>

<p>
All commands that modify the address register are given by accessing a
specific address in the I/O space of the drive CPU. It does not matter if the
access is a read or a write access. The data is ignored: if you do a read
access, the data that's read has no meaning, and if the access is a write,
the data has no effect.
However, the address space for the address register is shared with a possible
real-time clock module on one of the clockports of the machine. Therefore,
read accesses from the registers are recommended in order not to overwrite
the RTC time. 
</p>

<p>
The Address register can only be set. The current state of the register
cannot be read! If you need to know where the address register currently
points, you have to keep a shadow register in your code. The following
addresses only apply to the drive CPU. The flash rom can also be accessed
through this bottleneck from the main CPU, but this will be in a different
address space. Documentation for this will follow later.
</p>

<p>
To clear the address register, read from $3f60.
</p>

<!--
<p>
To preset the address register to $00555, read from $3f62.
</p>

<p>
To preset the address register to $002aa, read from $3f64.
</p>
-->

<p>
To shift the current address one bit left, read from $3f66. By shifting left,
the MSB is shifted "out" (into nirvana), and a 0 is shifted into the LSB.
This operation can also be seen as a multiplication by 2.
</p>

<p>
To increment the counter by 1, read from $3f68. Increment can be used to set
the LSB after shifting left, or to count the full register up (the full carry
is implemented!).
</p>

<p>
The above commands can be used as often as necessary to get to the desired
address. During the proess of setting the address, no access is done to the
flash rom itself.
<!-- The preset values help speeding up the process for frequently
used addresses of industry-standard flash rom chips. Some of them use 0x0555
and 0x02aa as the "magic addresses", others use 0x5555 and 0x2aaa. These can
still be accessed a lot faster by using the presets and shifting in the
remaining four bits with the shift/increment combination like this:
-->
</p>

<!--
<pre>
  LDA #$3f62 ;preset to 0x0555 - no clear nocessary!
  LDA #$3f66 ;shift left, address now 0x0aaa
  LDA #$3f66 ;shift left, address now 0x1554
  LDA #$3f68 ;increment,  address now 0x1555
  LDA #$3f66 ;shift left, address now 0x2aaa
</pre>

<p>
As you can see, there's no need to delay between the accesses. Just fire them
out as fast as you can :-)
</p>
-->

<p>
After setting the address, the data of the flash rom can be accessed by
reading from or writing to the following addresses<!-- (corresponding flash rom
addresses in brackets given for the example above)-->:
</p>

<pre>
  $3f6c (0x0xxxx)
  $3f6d (0x2xxxx)
  $3f6e (0x4xxxx)
  $3f6f (0x6xxxx)
</pre>

<p>
The addresses in brackets only apply to 512K flash roms (type 29F040). If a
128K type is used (29F010 or similar), all register addresses go to 0x02aaa
of the chip. Accessing the rom chip through these four registers does not
alter the address in the address register. You can write to the register, and
immediately read back the value (verify-access) as often as necessary.
</p>

<p>
The drive CPU can also access other parts of the computer through it's I/O
ports. This might be interesting for future use, like reacting to a CBM
cartridge in the cartridge slot. Although only the first 16 bytes of the
cartridge can be "seen", it's enough to make a recommendation to the user to
use a C64 compatible core if the CBM80 string is detected:
</p>

<pre>
  $3f00   <span style="text-decoration: overline">ROML</span> (cartridge)
  $3f10   <span style="text-decoration: overline">I/O2</span> (cartridge)
  $3f20   Clockport1 (spare chip-select, for example Silversurfer or RR-Net)
  $3f30   SID1 (not enough registers, SID cannot be used!)
  $3f40   <span style="text-decoration: overline">ROMH</span> (cartridge)
  $3f50   <span style="text-decoration: overline">I/O1</span> (cartridge)
  $3f60   Clockport2 (RTC select, real-time clock and flash rom address)
  $3f70   SID2 (not enough registers, SID cannot be used!)
</pre>


<h2>AMD notes</h2>

<p>
From my experience from the Retro Replay and Kickflash, I know that
AMD flash roms do not always behave as described in the
datasheets. The different versions of the flash roms are not easily to
identify, usually not by software. The big problems began on the Retro
Replay when we started to use 29F010B flash roms. They would program
properly, but would not erase. We worked out a lot, even contacted AMD
for assistance and did literally everything what they suggested:
Tested for spikes on the select/oe/write lines, made scope shots and
sent them to the AMD engineers, and even got hold of an internal AMD
document that describes a few changes from 29F010 to 29F010B. But
still, the "multiple sector erase" command did not work!
</p>

<p>
Count 0's findings, as well as my findings prove that AMD f*cked up on
that command with the die-shrink that they obviously made moving
towards the B version of the chip. They might have done the same on
the 29F040 (blank, A or B suffix), and this is a warning to you
programmers: if one command of the flash chip works (such as chip
identify and sector protection status read), <b>all</b> other commands
should work as well. If multiple sector erase does not work, try
erasing single sectors. That's what we did on the Retro Replay, and
it'll save you a lot of time, and only cost a few seconds on the user
end.
</p>


</body>
</html>
